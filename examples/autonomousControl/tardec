Completed Tasks:


1) NLOptControl.jl

In order to control the vehicle in real-time a software package was created called NLOptControl.jl. The features of this package include:

Dynamic Constraint Equations:
Currently there is a choice between three integration schemes; implicit backward Euler, trapezoidal method, and a multiple interval pseudo-spectral method (similar to GPOPS-ii). A lot of work went into implementing the multiple pseudo-spectral method for solving the dynamic constraint equations so that it runs fast and is easy to use.

Final Time as a Design Variable:
In  optimal control problems, often the final time is unknown. So, time had to be added as an optional design variable. Incorporating this option was a difficult task this into was a difficult task, but was accomplished and validated using symbolic differentiation.

Nonlinear Time-Varying Constraints
Moving obstacle avoidance is one of the main features of (my project). Writing functionality to allow the user to use the time vector, where the last point of that vector may be a design variable) inside of the constraint equations was also accomplished.

Integral Terms in the Objective Function:
Adding and removing terms in the objective function happens frequently when solving optimal control problems. So, functionality was developed so the user can add or remove these terms with a single line of code.

Model-Predictive Control (MPC):
A module in NLOptControl.jl was developed to allow the user to easily solve their problem in a receding time-horizon using MPC. When solving these types of problems, there is a huge amount of data that is can be stored and is very organized.

Control of Tolerances:
When solving optimal control problems, it is critical to have control over the tolerances on the initial states, the final states, and all of the constant state constraints and NLOptControl.jl provides this capability. Additionally, when solving MPC problems, it was found that one of the major challenges was that when the controller finds solutions very close to the bounds and the plant executes these solutions. Then, due to differences between the plant and the controller the plant may drive outside of these bounds, then when the optimization problem is initialized, it is infeasible. To mitigate these issues, functionality was developed to turn a constant constraint into a linear constraint. Then, by tapering the constraints to be tighter towards the end of the prediction horizon we are able to reduce the chance that the plant will operate too closely to these bounds.

Infeasibility and Constraints:
Formulating a nonlinear control problems can be very difficult. Often, the solutions can be infeasible and the first question, is why. NLOptControl.jl allows the options to save and process the constraint data so that the user can quickly determine what constraints where not met so they can modify their problem accordingly. Additionally, if the constraints are linearly dependent, then the system is degenerate and poorly designed. To deal with these issues, an external package (DegeneracyHunter.jl) was utilized to carefully constraint (my project).

Visualization:
For ease of use, the solution to any problem solved using NLOptControl.jl can be automatically visualized using another package that was developed called PrettyPlots.jl.

Automatic Differentiation:
In (Jiechao's Project) the Hessians and Jacobians needed to be configured manually. This is difficult and time consuming and if any of the constraints or terms in the objective function change it must be redone so development time is increased. (This project), leverages the tools built in julia that provide Automatic Differentiation capabilities, so the Hessians and Jacobians are calculated automatically and in real-time. Taking this automated approach greatly reduces both human error and development time.

Testing and Development:
In  order to test NLOptControl.jl, several simple problems where solved including the Brachistochrone problem, the Bryson Denham problem a Kinematic Bicycle problem and a simple Moon Lander problem. These problems are now examples that can be studied by a new user and are written in about 30 lines of code (including Visualizations). One of the benefits of having these examples is that new features can be easily tested and verified.

Flexibility:
Our software needs are very specific, demanding, and constantly in flux. By designing and developing our own tools such as NLOptControl.jl, we can easily develop the software to test new ideas.

Speed:
While formal testing and benchmarking against similar commercial tools, like GPOPT-ii in MATLAB, NLOptControl.jl is extremely fast and is expected to perform extremely well.

2) VehicleModels.jl

Leveraging the work from (Jiechao's project), the 3DOF 8 state vehicle model with the nonlinear combined slip Pacejka tire model was added to a package called VehicleModels.jl. This model was designed to be used with NLOptControl.jl and was validated against the MATLAB version.

3) MAVs.jl

Using NLOptControl.jl, PrettyPlots.jl and VehicleModels.jl, significant progress was made towards the goals of (my project). For organization, yet another package was developed called MAVs.jl (Michigan Autonomous Vehicles). In this package there are several modules
  A) AutonomousControl.jl

  B) SharedControl.jl

  C) PathFollowing.jl

  D) SimpleModel.jl
  This package is a working progress, but the idea is that we can run a simple version of our complicated problem to get a good initialization of the problem. A simple model of our problem was developed, but utilizing the solution of this problem to initialize our more complicated problem has yet to be done.

  E) CaseModule.jl


4) LiDAR models

5) Publications:

Moving Obstacle A.....

6) Presentations:

JuliaCon 2017:
This summer a workshop will be given at JuliCon at Berkeley on NLOptControl.jl.
http://juliacon.org/2017/talks.html#workshop-4


ACC 2017
The work 
ARC 2016
